var assert=require("assert");var proxyaddr=require("..");describe("proxyaddr(req, trust)",function(){describe("arguments",function(){describe("req",function(){it("should be required",function(){assert.throws(proxyaddr,/req.*required/)})});describe("trust",function(){it("should be required",function(){var r=createReq("127.0.0.1");assert.throws(proxyaddr.bind(null,r),/trust.*required/)});it("should accept a function",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,all))});it("should accept an array",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,[]))});it("should accept a string",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,"127.0.0.1"))});it("should reject a number",function(){var r=createReq("127.0.0.1");assert.throws(proxyaddr.bind(null,r,42),/unsupported trust argument/)});it("should accept IPv4",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,"127.0.0.1"))});it("should accept IPv6",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,"::1"))});it("should accept IPv4-style IPv6",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,"::ffff:127.0.0.1"))});it("should accept pre-defined names",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,"loopback"))});it("should accept pre-defined names in array",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,r,["loopback","10.0.0.1"]))});it("should not alter input array",function(){var r=["loopback","10.0.0.1"];var e=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.bind(null,e,r));assert.deepEqual(r,["loopback","10.0.0.1"])});it("should reject non-IP",function(){var r=createReq("127.0.0.1");assert.throws(proxyaddr.bind(null,r,"blargh"),/invalid IP address/);assert.throws(proxyaddr.bind(null,r,"10.0.300.1"),/invalid IP address/);assert.throws(proxyaddr.bind(null,r,"::ffff:30.168.1.9000"),/invalid IP address/);assert.throws(proxyaddr.bind(null,r,"-1"),/invalid IP address/)});it("should reject bad CIDR",function(){var r=createReq("127.0.0.1");assert.throws(proxyaddr.bind(null,r,"10.0.0.1/internet"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"10.0.0.1/6000"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"::1/6000"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"::ffff:a00:2/136"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"::ffff:a00:2/-1"),/invalid range on address/)});it("should reject bad netmask",function(){var r=createReq("127.0.0.1");assert.throws(proxyaddr.bind(null,r,"10.0.0.1/255.0.255.0"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"10.0.0.1/ffc0::"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"fe80::/ffc0::"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"fe80::/255.255.255.0"),/invalid range on address/);assert.throws(proxyaddr.bind(null,r,"::ffff:a00:2/255.255.255.0"),/invalid range on address/)});it("should be invoked as trust(addr, i)",function(){var a=[];var r=createReq("127.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.1"});proxyaddr(r,function(r,e){return a.push(Array.prototype.slice.call(arguments))});assert.deepEqual(a,[["127.0.0.1",0],["10.0.0.1",1]])})})});describe("with all trusted",function(){it("should return socket address with no headers",function(){var r=createReq("127.0.0.1");assert.equal(proxyaddr(r,all),"127.0.0.1")});it("should return header value",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1"});assert.equal(proxyaddr(r,all),"10.0.0.1")});it("should return furthest header value",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,all),"10.0.0.1")})});describe("with none trusted",function(){it("should return socket address with no headers",function(){var r=createReq("127.0.0.1");assert.equal(proxyaddr(r,none),"127.0.0.1")});it("should return socket address with headers",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,none),"127.0.0.1")})});describe("with some trusted",function(){it("should return socket address with no headers",function(){var r=createReq("127.0.0.1");assert.equal(proxyaddr(r,trust10x),"127.0.0.1")});it("should return socket address when not trusted",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,trust10x),"127.0.0.1")});it("should return header when socket trusted",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1"});assert.equal(proxyaddr(r,trust10x),"192.168.0.1")});it("should return first untrusted after trusted",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,trust10x),"192.168.0.1")});it("should not skip untrusted",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"10.0.0.3, 192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,trust10x),"192.168.0.1")})});describe("when given array",function(){it("should accept literal IP addresses",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,["10.0.0.1","10.0.0.2"]),"192.168.0.1")});it("should not trust non-IP addresses",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2, localhost"});assert.equal(proxyaddr(r,["10.0.0.1","10.0.0.2"]),"localhost")});it("should return socket address if none match",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,["127.0.0.1","192.168.0.100"]),"10.0.0.1")});describe("when array empty",function(){it("should return socket address ",function(){var r=createReq("127.0.0.1");assert.equal(proxyaddr(r,[]),"127.0.0.1")});it("should return socket address with headers",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,[]),"127.0.0.1")})})});describe("when given IPv4 addresses",function(){it("should accept literal IP addresses",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,["10.0.0.1","10.0.0.2"]),"192.168.0.1")});it("should accept CIDR notation",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.200"});assert.equal(proxyaddr(r,"10.0.0.2/26"),"10.0.0.200")});it("should accept netmask notation",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.200"});assert.equal(proxyaddr(r,"10.0.0.2/255.255.255.192"),"10.0.0.200")})});describe("when given IPv6 addresses",function(){it("should accept literal IP addresses",function(){var r=createReq("fe80::1",{"x-forwarded-for":"2002:c000:203::1, fe80::2"});assert.equal(proxyaddr(r,["fe80::1","fe80::2"]),"2002:c000:203::1")});it("should accept CIDR notation",function(){var r=createReq("fe80::1",{"x-forwarded-for":"2002:c000:203::1, fe80::ff00"});assert.equal(proxyaddr(r,"fe80::/125"),"fe80::ff00")})});describe("when IP versions mixed",function(){it("should match respective versions",function(){var r=createReq("::1",{"x-forwarded-for":"2002:c000:203::1"});assert.equal(proxyaddr(r,["127.0.0.1","::1"]),"2002:c000:203::1")});it("should not match IPv4 to IPv6",function(){var r=createReq("::1",{"x-forwarded-for":"2002:c000:203::1"});assert.equal(proxyaddr(r,"127.0.0.1"),"::1")})});describe("when IPv4-mapped IPv6 addresses",function(){it("should match IPv4 trust to IPv6 request",function(){var r=createReq("::ffff:a00:1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,["10.0.0.1","10.0.0.2"]),"192.168.0.1")});it("should match IPv4 netmask trust to IPv6 request",function(){var r=createReq("::ffff:a00:1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,["10.0.0.1/16"]),"192.168.0.1")});it("should match IPv6 trust to IPv4 request",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.2"});assert.equal(proxyaddr(r,["::ffff:a00:1","::ffff:a00:2"]),"192.168.0.1")});it("should match CIDR notation for IPv4-mapped address",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.200"});assert.equal(proxyaddr(r,"::ffff:a00:2/122"),"10.0.0.200")});it("should match CIDR notation for IPv4-mapped address mixed with IPv6 CIDR",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.200"});assert.equal(proxyaddr(r,["::ffff:a00:2/122","fe80::/125"]),"10.0.0.200")});it("should match CIDR notation for IPv4-mapped address mixed with IPv4 addresses",function(){var r=createReq("10.0.0.1",{"x-forwarded-for":"192.168.0.1, 10.0.0.200"});assert.equal(proxyaddr(r,["::ffff:a00:2/122","127.0.0.1"]),"10.0.0.200")})});describe("when given pre-defined names",function(){it("should accept single pre-defined name",function(){var r=createReq("fe80::1",{"x-forwarded-for":"2002:c000:203::1, fe80::2"});assert.equal(proxyaddr(r,"linklocal"),"2002:c000:203::1")});it("should accept multiple pre-defined names",function(){var r=createReq("::1",{"x-forwarded-for":"2002:c000:203::1, fe80::2"});assert.equal(proxyaddr(r,["loopback","linklocal"]),"2002:c000:203::1")})});describe("when header contains non-ip addresses",function(){it("should stop at first non-ip after trusted",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"myrouter, 127.0.0.1, proxy"});assert.equal(proxyaddr(r,"127.0.0.1"),"proxy")});it("should stop at first malformed ip after trusted",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"myrouter, 127.0.0.1, ::8:8:8:8:8:8:8:8:8"});assert.equal(proxyaddr(r,"127.0.0.1"),"::8:8:8:8:8:8:8:8:8")});it("should provide all values to function",function(){var a=[];var r=createReq("127.0.0.1",{"x-forwarded-for":"myrouter, 127.0.0.1, proxy"});proxyaddr(r,function(r,e){return a.push(Array.prototype.slice.call(arguments))});assert.deepEqual(a,[["127.0.0.1",0],["proxy",1],["127.0.0.1",2]])})});describe("when socket address undefined",function(){it("should return undefined as address",function(){var r=createReq(undefined);assert.strictEqual(proxyaddr(r,"127.0.0.1"),undefined)});it("should return undefined even with trusted headers",function(){var r=createReq(undefined,{"x-forwarded-for":"127.0.0.1, 10.0.0.1"});assert.strictEqual(proxyaddr(r,"127.0.0.1"),undefined)})})});describe("proxyaddr.all(req, [trust])",function(){describe("arguments",function(){describe("req",function(){it("should be required",function(){assert.throws(proxyaddr.all,/req.*required/)})});describe("trust",function(){it("should be optional",function(){var r=createReq("127.0.0.1");assert.doesNotThrow(proxyaddr.all.bind(null,r))})})});describe("with no headers",function(){it("should return socket address",function(){var r=createReq("127.0.0.1");assert.deepEqual(proxyaddr.all(r),["127.0.0.1"])})});describe("with x-forwarded-for header",function(){it("should include x-forwarded-for",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1"});assert.deepEqual(proxyaddr.all(r),["127.0.0.1","10.0.0.1"])});it("should include x-forwarded-for in correct order",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1, 10.0.0.2"});assert.deepEqual(proxyaddr.all(r),["127.0.0.1","10.0.0.2","10.0.0.1"])})});describe("with trust argument",function(){it("should stop at first untrusted",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1, 10.0.0.2"});assert.deepEqual(proxyaddr.all(r,"127.0.0.1"),["127.0.0.1","10.0.0.2"])});it("should be only socket address for no trust",function(){var r=createReq("127.0.0.1",{"x-forwarded-for":"10.0.0.1, 10.0.0.2"});assert.deepEqual(proxyaddr.all(r,[]),["127.0.0.1"])})})});describe("proxyaddr.compile(trust)",function(){describe("arguments",function(){describe("trust",function(){it("should be required",function(){assert.throws(proxyaddr.compile,/argument.*required/)});it("should accept an array",function(){assert.equal(typeof proxyaddr.compile([]),"function")});it("should accept a string",function(){assert.equal(typeof proxyaddr.compile("127.0.0.1"),"function")});it("should reject a number",function(){assert.throws(proxyaddr.compile.bind(null,42),/unsupported trust argument/)});it("should accept IPv4",function(){assert.equal(typeof proxyaddr.compile("127.0.0.1"),"function")});it("should accept IPv6",function(){assert.equal(typeof proxyaddr.compile("::1"),"function")});it("should accept IPv4-style IPv6",function(){assert.equal(typeof proxyaddr.compile("::ffff:127.0.0.1"),"function")});it("should accept pre-defined names",function(){assert.equal(typeof proxyaddr.compile("loopback"),"function")});it("should accept pre-defined names in array",function(){assert.equal(typeof proxyaddr.compile(["loopback","10.0.0.1"]),"function")});it("should reject non-IP",function(){assert.throws(proxyaddr.compile.bind(null,"blargh"),/invalid IP address/);assert.throws(proxyaddr.compile.bind(null,"-1"),/invalid IP address/)});it("should reject bad CIDR",function(){assert.throws(proxyaddr.compile.bind(null,"10.0.0.1/6000"),/invalid range on address/);assert.throws(proxyaddr.compile.bind(null,"::1/6000"),/invalid range on address/);assert.throws(proxyaddr.compile.bind(null,"::ffff:a00:2/136"),/invalid range on address/);assert.throws(proxyaddr.compile.bind(null,"::ffff:a00:2/-46"),/invalid range on address/)});it("should not alter input array",function(){var r=["loopback","10.0.0.1"];assert.equal(typeof proxyaddr.compile(r),"function");assert.deepEqual(r,["loopback","10.0.0.1"])})})})});function createReq(r,e){return{connection:{remoteAddress:r},headers:e||{}}}function all(){return true}function none(){return false}function trust10x(r){return/^10\./.test(r)}
